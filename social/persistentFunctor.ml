(*
 * database.ml - fpgg home
 *
 * William Le Ferrand william@hypios.com
 *
 *
 *)

open Lwt

let debug' = Printf.printf

(* let mtx = Mutex.create () *)

let mtx = ()

(*
let mtx_call mtx f =
  Lwt_preemptive.detach
    (fun () ->
      Mutex.lock mtx ;
      try
	let v = f () in
	Mutex.unlock mtx ;
	v
      with e -> debug' "PANIC in mtx_call: %s\n" (Printexc.to_string e); Mutex.unlock mtx ; raise e) () (* This abort the thread and might lock the call *)
*)

let mtx_call _ f =
  return (f ())
(** Persistent structure functor *)

let mtx_call _ f =
  Lwt_preemptive.detach f () (* MAAANNNDATORY - il y a un unix.sleep planquÃ© dans l'orm ;( *)

module type CELT =
  sig
    (* Manipulated type *)
    type t

    (* Autogenerated functions *)
    val init : string -> (t, [ `RW ]) Orm.Db.t
    val get_by_id : id:[< `Eq of int64 ] -> (t, [< `RO | `RW ]) Orm.Db.t -> t
    val id : db:(t, [< `RO | `RW ]) Orm.Db.t -> t -> int64
    val get : (t -> bool) -> (t, [< `RO | `RW ]) Orm.Db.t -> t list
    val save : db:(t, [ `RW ]) Orm.Db.t -> t -> bool -> unit
    val delete : ?recursive:bool -> db:(t, [ `RW ]) Orm.Db.t -> t -> unit
    val search : db:(t, [ `RW ]) Orm.Db.t -> string -> string -> int64 list

    (* Type-dependant functions, customized loaders  *)
(*    val customs : (int64 -> t -> bool) array *)
  end


module type CDATABASE =
  sig
    type t
    val load : int64 -> t Lwt.t
    val load_all : unit -> t list Lwt.t
    val load_custom : (t -> bool) -> t list Lwt.t

    val save : t -> unit Lwt.t
    val delete : t -> unit Lwt.t
    val id : t -> int64

    val search : string -> string -> int64 list Lwt.t

(*    val loaders : (int64 -> t list Lwt.t) array *)
    val make_custom : ('a -> t -> bool) -> 'a -> t list Lwt.t

  end

module type CDATABASEFUNCTOR = functor (C : CELT) ->
  CDATABASE with type t = C.t

(*  sig
    type t = C.t
    val load : int64 -> t Lwt.t
    val load_all : unit -> t list Lwt.t

    val save : t -> unit Lwt.t
    val delete : t -> unit Lwt.t
    val id : t -> int64

    val search : string -> string -> int64 list Lwt.t

    val loaders : (int64 -> t list Lwt.t) array
    val filters : (int64 -> t -> bool) array

  end
*)

module Make : CDATABASEFUNCTOR =
  functor (C : CELT) ->
    struct
      type t = C.t

      let _ = debug' "Building the db module\n"
      let db = C.init Params.sqlite_db
      let _ = debug' "db value computed\n"
      let id e = C.id ~db e

      let load id =
        mtx_call mtx (fun () -> C.get_by_id ~id:(`Eq id) db)

      let load_all () =
        mtx_call mtx (fun () -> C.get (fun _ -> true) db)

      let load_custom custom =
        mtx_call mtx (fun () -> C.get custom db)

      let save e =
        mtx_call mtx (fun () -> C.save ~db e true)

      let delete e =
        mtx_call mtx (fun () -> C.delete ~db e)

      let search field query =
	mtx_call mtx (fun () -> C.search ~db field query)

(*
      let loaders =
	Array.map
	  (fun custom id ->
	     mtx_call mtx (
	       fun () ->
	         C.get (custom id) db
	     )
	  )
	  C.customs

      let filters = C.customs
*)

      let make_custom custom =
	 (fun id ->
	     mtx_call mtx (
	       fun () ->
	         C.get (custom id) db
	     ))
    end






